#!/usr/bin/env python
# encoding: utf-8

import argparse
from pwn import *
from lib import Format_string
from lib import Arbitrarily_RW
from lib import Error_regs
from lib import Heap_vul
from lib import Stack_overflow
from pathlib import Path
import json

# from func_timeout import func_set_timeout
# import time
# import func_timeout

from multiprocessing import  Process

# import threading


def path_msg(inlist):
    for indir in inlist:
        print("\n---------------------------------------------")
        if "over_num" in indir:
            print("over bytes:",indir["over_num"])
        if "stdout" in indir:
            print("stdout:",indir["stdout"])
        if "stdin" in indir:
            print("stdin:",indir["stdin"])
        if "chain" in indir:
            print("jump chain:",indir["chain"])
        if "argv" in indir:
            print("argv:",indir["argv"])
        print()


def find_stack_repeat(limit=None):
    stack_overflow(filename,args=argv,start_addr=entry_addr,limit=limit)
def find_stack_msg(limit=None):
    p = Process(target=find_stack_repeat,args=(limit,))#
    p.start()
    p.join(limit_time)
    if p.is_alive():
        print("[-] runing over limit time,kill it")
        p.terminate()
    p.join()

    fp=None
    try:
        fp=open("tmp.json","r+")
    except :
        print("find nothing in stack overflow vulnerability!")
        return

    bp_overflow_result=[]
    pc_overflow_result=[]
    while True:
        str_line =fp.readline()
        if  str_line:
            # print(bytes(str_line,"utf-8"))
            json_str = json.loads(str_line)
            # print(type(json_str))
            for k in json_str:
                if k=="bp_overflow_result":
                    bp_overflow_result.append(json_str["bp_overflow_result"])
                if k=="pc_overflow_result":
                    pc_overflow_result.append(json_str["pc_overflow_result"])
        else:
            break
    fp.seek(0)
    fp.truncate()
    fp.close()
    os.system("rm tmp.json")

    print("\n[+]===has found",len(bp_overflow_result),"stack overflow to BP===")
    path_msg(bp_overflow_result)

    print("\n[+]===has found",len(pc_overflow_result),"stack overflow to PC===")
    path_msg(pc_overflow_result)


def find_stack_overflow():
    times=1
    find_stack_msg()
    
    while True:
        print("[+] attempt to find stack overflow vulnerability for {} times".format(times))
        print("1.try again; 2.change limit; 3.return to menu")
        print("input your choice:")
        choice=input()
        try:
            choice=int(choice)
        except:
            print("error input, it must be a num!")
            continue

        if choice==1:
            find_stack_msg()
            times+=1
            continue

        if choice==2:
            print("input your limit num:")
            limit=input()
            print("input runing time(min):")
            mins=input()
            try:
                limit=int(limit)
                mins=int(mins)
            except:
                print("error input, it must be a num!")
                continue
            global limit_time
            limit_time=one_min*mins

            find_stack_msg(limit=limit)
            times+=1
            continue

        if choice==3:
            print("[+] find_stack_overflow() over")
            return
        else:
            print("error input, try again!")
            continue



def find_arbitrary_repeat(limit=None):
    arbitrary_RW_vulnerability(filename,args=argv,start_addr=entry_addr,limit=limit)
def find_arbitrary_msg(limit=None):
    p = Process(target=find_arbitrary_repeat,args=(limit,))#
    p.start()
    p.join(limit_time)
    if p.is_alive():
        print("[-] runing over limit time,kill it")
        p.terminate()
    p.join()

    fp=None
    try:
        fp=open("tmp.json","r+")
    except :
        print("find nothing in arbitrary RW vulnerability!")
        return
    arbitrary_R_result=[]
    arbitrary_W_result=[]
    while True:
        str_line =fp.readline()
        if  str_line:
            # print(bytes(str_line,"utf-8"))
            json_str = json.loads(str_line)
            # print(type(json_str))
            for k in json_str:
                if k=="arbitrary_W_result":
                    arbitrary_W_result.append(json_str["arbitrary_W_result"])
                if k=="arbitrary_R_result":
                    arbitrary_R_result.append(json_str["arbitrary_R_result"])
        else:
            break
    fp.seek(0)
    fp.truncate()
    fp.close()
    os.system("rm tmp.json")

    print("\n[+]===has found",len(arbitrary_W_result),"arbitrary write===")
    path_msg(arbitrary_W_result)

    print("\n[+]===has found",len(arbitrary_R_result),"arbitrary read===")
    path_msg(arbitrary_R_result)

def find_arbitrary():
    times=1
    find_arbitrary_msg()
    
    while True:
        print("[+] attempt to find arbitrary RW vulnerability for {} times".format(times))
        print("1.try again; 2.change limit; 3.return to menu")
        print("input your choice:")
        choice=input()
        try:
            choice=int(choice)
        except:
            print("error input, it must be a num!")
            continue

        if choice==1:
            find_arbitrary_msg()
            times+=1
            continue

        if choice==2:
            print("input your limit num:")
            limit=input()
            print("input runing time(min):")
            mins=input()
            try:
                limit=int(limit)
                mins=int(mins)
            except:
                print("error input, it must be a num!")
                continue
            global limit_time
            limit_time=one_min*mins

            find_arbitrary_msg(limit=limit)
            times+=1
            continue

        if choice==3:
            print("[+] find_arbitrary() over")
            return
        else:
            print("error input, try again!")
            continue


def find_error_regs_repeat(limit=None):
    error_regs(filename,args=argv,start_addr=entry_addr,limit=limit)
def find_error_regs_msg(limit=None):
    p = Process(target=find_error_regs_repeat,args=(limit,))#
    p.start()
    p.join(limit_time)
    if p.is_alive():
        print("[-] runing over limit time,kill it")
        p.terminate()
    p.join()

    fp=None
    try:
        fp=open("tmp.json","r+")
    except :
        print("find nothing in error regs vulnerability!")
        return
    pc_error_result=[]
    bp_error_result=[]
    sp_error_result=[]
    unknow_error_result=[]
    while True:
        str_line =fp.readline()
        if  str_line:
            # print(bytes(str_line,"utf-8"))
            json_str = json.loads(str_line)
            # print(type(json_str))
            for k in json_str:
                if k=="pc_error_result":
                    pc_error_result.append(json_str["pc_error_result"])
                if k=="sp_error_result":
                    sp_error_result.append(json_str["sp_error_result"])
                if k=="bp_error_result":
                    bp_error_result.append(json_str["bp_error_result"])
                if k=="unknow_error_result":
                    unknow_error_result.append(json_str["unknow_error_result"])
        else:
            break
    fp.seek(0)
    fp.truncate()
    fp.close()
    os.system("rm tmp.json")

    print("\n[+]===has found",len(pc_error_result),"pc reg error===")
    path_msg(pc_error_result)
    print("\n[+]===has found",len(sp_error_result),"sp reg read===")
    path_msg(sp_error_result)
    print("\n[+]===has found",len(bp_error_result),"bp reg read===")
    path_msg(bp_error_result)
    print("\n[+]===has found",len(unknow_error_result),"unknow error===")
    path_msg(unknow_error_result)

def find_error_regs():
    times=1
    find_error_regs_msg()
    
    while True:
        print("[+] attempt to find error regs vulnerability for {} times".format(times))
        print("1.try again; 2.change limit; 3.return to menu")
        print("input your choice:")
        choice=input()
        try:
            choice=int(choice)
        except:
            print("error input, it must be a num!")
            continue

        if choice==1:
            find_error_regs_msg()
            times+=1
            continue

        if choice==2:
            print("input your limit num:")
            limit=input()
            print("input runing time(min):")
            mins=input()
            try:
                limit=int(limit)
                mins=int(mins)
            except:
                print("error input, it must be a num!")
                continue
            global limit_time
            limit_time=one_min*mins
            
            find_error_regs_msg(limit=limit)
            times+=1
            continue

        if choice==3:
            print("[+] find_error_regs() over")
            return
        else:
            print("error input, try again!")
            continue


def find_format_repeat(limit=None):
    fmt_vulnerability(filename,args=argv,start_addr=entry_addr,limit=limit)

def find_format_msg(limit=None):
    p = Process(target=find_format_repeat,args=(limit,))#
    p.start()
    p.join(limit_time)
    if p.is_alive():
        print("[-] runing over limit time,kill it")
        p.terminate()
    p.join()

    fp=None
    try:
        fp=open("tmp.json","r+")
    except :
        print("find nothing in format string vulnerability!")
        return
    fmt_result=[]

    while True:
        str_line =fp.readline()
        if  str_line:
            json_str = json.loads(str_line)
            for k in json_str:
                if k=="fmt_result":
                    fmt_result.append(json_str["fmt_result"])       
        else:
            break

    fp.seek(0)
    fp.truncate()
    fp.close()
    os.system("rm tmp.json")

    print("\n[+]===has found",len(fmt_result),"fmt string vulnerability===")
    path_msg(fmt_result)
    

def find_format():
    times=1
    find_format_msg()
    
    while True:
        print("[+] attempt to find fmt string vulnerability for {} times".format(times))
        print("1.try again; 2.change limit; 3.return to menu")
        print("input your choice:")
        choice=input()
        try:
            choice=int(choice)
        except:
            print("error input, it must be a num!")
            continue

        if choice==1:
            find_format_msg()
            times+=1
            continue

        if choice==2:
            print("input your limit num:")
            limit=input()
            print("input runing time(min):")
            mins=input()
            try:
                limit=int(limit)
                mins=int(mins)
            except:
                print("error input, it must be a num!")
                continue
            global limit_time
            limit_time=one_min*mins

            find_format_msg(limit=limit)
            times+=1
            continue

        if choice==3:
            print("[+] find_format() over")
            return
        else:
            print("error input, try again!")
            continue




def find_heap_vul_repeat(limit=None):
    heap_vulnerability(filename,args=argv,start_addr=entry_addr,limit=limit)
    
def find_heap_vul_msg(limit=None):
    p = Process(target=find_heap_vul_repeat,args=(limit,))#
    p.start()
    p.join(limit_time)
    if p.is_alive():
        print("[-] runing over limit time,kill it")
        p.terminate()
    p.join()

    fp=None
    try:
        fp=open("tmp.json","r+")
    except :
        print("find nothing in heap vulnerability!")
        return

    uaf_R_result=[]
    uaf_W_result=[]
    double_free_result=[]
    error_free_result=[]
    while True:
        str_line =fp.readline()
        if  str_line:
            # print(bytes(str_line,"utf-8"))
            json_str = json.loads(str_line)
            # print(type(json_str))
            for k in json_str:
                if k=="uaf_R_result":
                    uaf_R_result.append(json_str["uaf_R_result"])
                if k=="uaf_W_result":
                    uaf_W_result.append(json_str["uaf_W_result"])
                if k=="double_free_result":
                    double_free_result.append(json_str["double_free_result"])
                if k=="error_free_result":
                    error_free_result.append(json_str["error_free_result"])
        else:
            break
    fp.seek(0)
    fp.truncate()
    fp.close()
    os.system("rm tmp.json")

    print("\n[+]===has found",len(uaf_R_result),"uaf read===")
    path_msg(uaf_R_result)
    print("\n[+]===has found",len(uaf_W_result),"uaf write===")
    path_msg(uaf_W_result)
    print("\n[+]===has found",len(double_free_result),"double free===")
    path_msg(double_free_result)
    print("\n[+]===has found",len(error_free_result),"error free ptr===")
    path_msg(error_free_result)

def find_heap_vul():
    times=1
    find_heap_vul_msg()

    while True:
        print("[+] attempt to find heap vulnerability for {} times".format(times))
        print("1.try again; 2.change limit/time; 3.return to menu")
        print("input your choice:")
        choice=input()
        try:
            choice=int(choice)
        except:
            print("error input, it must be a num!")
            continue

        if choice==1:
            find_heap_vul_msg()
            times+=1
            continue

        if choice==2:
            print("input your limit num:")
            limit=input()
            print("input runing time(min):")
            mins=input()
            try:
                limit=int(limit)
                mins=int(mins)
            except:
                print("error input, it must be a num!")
                continue
            global limit_time
            limit_time=one_min*mins
            find_heap_vul_msg(limit=limit)
            times+=1
            continue

        if choice==3:
            print("[+] find_heap_vul() over")
            return
        else:
            print("error input, try again!")
            continue


def main():
    import os
    print("[+] the msg of target program:")
    os.system("checksec {}".format(filename))
    

    while True:
        print("[+] menu")
        print("---------------------------------")
        print("1.find the stack overflow vulnerability")
        print("2.find the arbitrary R&W vulnerability")
        print("3.find the error regs vulnerability")
        print("4.find the format string vulnerability")
        print("5.find the heap vulnerability")
        print("6.exit")
        print("---------------------------------")

        print("input your choice:")
        choice=input()
        try:
            choice=int(choice)
        except:
            print("error input, try again!")
            continue
        
        if choice==1:
            find_stack_overflow()
            continue
        if choice==2:
            find_arbitrary()
            continue
        if choice==3:
            find_error_regs()
            continue
        if choice==4:
            find_format()
            continue
        if choice==5:
            find_heap_vul()
            continue
        if choice==6:
            print("bye~")
            exit(1)
        else:
            print("error input, try again!")
            continue


if __name__ == '__main__':

    fmt_vulnerability = Format_string.Check_format_string
    arbitrary_RW_vulnerability = Arbitrarily_RW.Check_arbitrary_RW
    stack_overflow = Stack_overflow.Check_StackOverflow
    heap_vulnerability = Heap_vul.Check_heap
    error_regs = Error_regs.Check_regs_error
    one_min=60
    limit_time=one_min*20
    parser = argparse.ArgumentParser()
    parser.add_argument('file',help="the target program to analyze")
    parser.add_argument('-l','--args_size',help="the bytes of each arg to the target program",default=False)
    parser.add_argument('-n','--args_num',help="the num of args to the target program",default=False)
    parser.add_argument('-s','--start_addr',help="set the start_addr to the entry_addr to execve target program",default=False)

    args = parser.parse_args()
    filename=args.file

    if not Path(filename).is_file():
        print("[-] '{}' is not exist or not a file!".format(filename))
        exit(1)

    args_num=False
    args_size=False
    entry_addr=False
    argv=None

    if args.args_size or args.args_num:
        if args.args_size and args.args_num:
            try:
                args_size=int(args.args_size,16)
            except Exception as e:
                print("[-] invaild args_size! it must be a hex num")
                raise e
            try:
                args_num=int(args.args_num,16)
            except Exception as e:
                print("[-] invaild args_num! it must be a hex num")
                raise e
            argv=[]
            for _ in range(args_num):
                argv.append(args_size)
        else:
            print("[-] -l -n must use together")
            exit(1)

    

    if args.start_addr:
        try:
            entry_addr=int(args.start_addr,16)
        except Exception as e:
            print("[-] invaild entry_addr! it must be a hex num")
            raise e 

    main()
